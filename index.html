<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Receipt Processor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.0/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #dropZone { border: 2px dashed #ccc; padding: 20px; text-align: center; margin-bottom: 20px; }
        #dropZone.dragover { background-color: #e1e1e1; }
        #result { margin-top: 20px; }
        select { margin-bottom: 10px; padding: 5px; }
    </style>
</head>
<body>
    <h1>Receipt Processor</h1>
    <label for="ocrMethod">Choose OCR Method:</label>
    <select id="ocrMethod" onchange="updateOcrMethod()">
        <option value="google">Google Vision API</option>
        <option value="tesseract">Tesseract.js</option>
    </select>
    <div id="dropZone">Drop your receipt images or PDFs here, or click to select files.</div>
    <button onclick="processReceipts()">Process Receipts</button>
    <div id="result"></div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const resultDiv = document.getElementById('result');
        const ocrMethodSelect = document.getElementById('ocrMethod');
        let files = [];
        let ocrMethod = 'google';

        function updateOcrMethod() {
            ocrMethod = ocrMethodSelect.value;
        }

        // Handle file drop and selection
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            files = Array.from(e.dataTransfer.files);
            displayFiles();
        });

        dropZone.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = 'image/*,application/pdf';
            input.onchange = (e) => {
                files = Array.from(e.target.files);
                displayFiles();
            };
            input.click();
        });

        function displayFiles() {
            resultDiv.innerHTML = `<h3>Selected Files:</h3><ul>${files.map(file => `<li>${file.name}</li>`).join('')}</ul>`;
        }

        async function processReceipts() {
            resultDiv.innerHTML = '<h3>Processing...</h3>';
            const results = [];

            for (const file of files) {
                let base64 = await convertFileToBase64(file);
                let text = '';

                // Convert PDF to image if necessary
                if (file.type === 'application/pdf') {
                    const pdfData = await fetch(base64).then(res => res.arrayBuffer());
                    const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                    const pdf = await loadingTask.promise;
                    const page = await pdf.getPage(1); // Process first page
                    const viewport = page.getViewport({ scale: 1.5 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport }).promise;
                    base64 = canvas.toDataURL('image/jpeg');
                }

                if (ocrMethod === 'google') {
                    try {
                        const apiKey = 'AIzaSyDID5ib0eHNVrBYG0e5vfWQ9RkVinX4hNg'; // Replace with your Google Vision API Key
                        const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                requests: [{
                                    image: { content: base64.split(',')[1] },
                                    features: [{ type: 'DOCUMENT_TEXT_DETECTION', maxResults: 1 }],
                                    imageContext: { languageHints: ['en', 'zh-TW'] }
                                }]
                            })
                        });
                        const data = await response.json();
                        text = data.responses[0]?.fullTextAnnotation?.text || 'No text detected';
                    } catch (error) {
                        resultDiv.innerHTML += `<p>Error with Google Vision for ${file.name}: ${error.message}</p>`;
                    }
                } else if (ocrMethod === 'tesseract') {
                    try {
                        const { data: { text: tesseractText } } = await Tesseract.recognize(base64, 'eng+chi_tra', {
                            logger: m => console.log(m)
                        });
                        text = tesseractText || 'No text detected';
                    } catch (error) {
                        resultDiv.innerHTML += `<p>Error with Tesseract for ${file.name}: ${error.message}</p>`;
                    }
                }

                const extractedData = parseReceiptText(text);
                results.push({ filename: file.name, extractedData });
            }

            // Prepare data for a single Excel file with new columns
            const wb = XLSX.utils.book_new();
            const wsData = [['Filename', 'Field', 'Value', 'Purchase Date', 'Amount']];
            results.forEach(result => {
                const { filename, extractedData } = result;
                let purchaseDate = '';
                let amount = '';

                extractedData.forEach(({ field, value }) => {
                    // Standardize date format
                    if (field === 'Raw Text' && isPotentialDate(value)) {
                        purchaseDate = standardizeDate(value) || purchaseDate;
                    }
                    // Extract amount
                    if (field === 'Raw Text' && isCurrencyValue(value)) {
                        amount = extractAmount(value) || amount;
                    }
                    wsData.push([filename, field, value, purchaseDate, amount]);
                });
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'ReceiptData');
            XLSX.writeFile(wb, `all_receipts_extracted_${new Date().toISOString().split('T')[0]}.xlsx`);

            // Display results
            resultDiv.innerHTML += '<h3>Results:</h3><ul>' + results.map(r => {
                const formattedData = r.extractedData.map(d => `${d.field}: ${d.value}`).join('<br>');
                return `<li>${r.filename}: <pre>${formattedData}</pre></li>`;
            }).join('') + '</ul>';
            alert('A single Excel file has been generated with all receipt data.');
        }

        function parseReceiptText(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const parsedData = [];
            lines.forEach(line => {
                if (line.includes(':') || line.includes('|')) {
                    const [field, value] = line.includes(':') ? line.split(':').map(s => s.trim()) : line.split('|').map(s => s.trim());
                    if (field && value) parsedData.push({ field, value });
                } else {
                    parsedData.push({ field: 'Raw Text', value: line });
                }
            });
            return parsedData;
        }

        function isPotentialDate(value) {
            const datePatterns = [
                /\d{4}\/\d{2}\/\d{2}/, // e.g., 2025/01/13
                /\d{2}-\d{2}-\d{2}/,   // e.g., 01-20-25
                /\w{3} \w{3} \d{2} \d{4}/, // e.g., Sun Jan 19 2025
                /\w{3} \w{3} \d{4}/    // e.g., Mon Jan 20 2025
            ];
            return datePatterns.some(pattern => pattern.test(value));
        }

        function standardizeDate(value) {
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
                return date.toISOString().split('T')[0]; // YYYY-MM-DD
            }
            // Handle specific formats manually
            const matchFull = value.match(/(\d{4})\/(\d{2})\/(\d{2})/);
            if (matchFull) return `${matchFull[1]}-${matchFull[2]}-${matchFull[3]}`;
            const matchShort = value.match(/(\d{2})-(\d{2})-(\d{2})/);
            if (matchShort) return `20${matchShort[3]}-${matchShort[1]}-${matchShort[2]}`;
            const matchDay = value.match(/(\w{3}) (\w{3}) (\d{2}) (\d{4})/);
            if (matchDay) {
                const months = { Jan: '01', Feb: '02', Mar: '03', Apr: '04', May: '05', Jun: '06',
                               Jul: '07', Aug: '08', Sep: '09', Oct: '10', Nov: '11', Dec: '12' };
                const month = months[matchDay[2]];
                return `${matchDay[4]}-${month}-${matchDay[3].padStart(2, '0')}`;
            }
            const matchNoDay = value.match(/(\w{3}) (\w{3}) (\d{4})/);
            if (matchNoDay) {
                const months = { Jan: '01', Feb: '02', Mar: '03', Apr: '04', May: '05', Jun: '06',
                               Jul: '07', Aug: '08', Sep: '09', Oct: '10', Nov: '11', Dec: '12' };
                const month = months[matchNoDay[2]];
                return `${matchNoDay[3]}-${month}-01`; // Default to 1st if no day
            }
            return '';
        }

        function isCurrencyValue(value) {
            return /[TWD|NT\$|\$]\s*\d{1,3}(?:,\d{3})*(?:\.\d{2})?/.test(value);
        }

        function extractAmount(value) {
            const match = value.match(/[TWD|NT\$|\$]\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/);
            return match ? match[1].replace(',', '') : '';
        }

        function convertFileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
    </script>
</body>
</html>
